import simpa.core.impl.DataIngestorServiceImpl02
import simpa.core.DataIngestorService
import simpa.core.Tile
import simpa.annotation.AnnotationLookupService
import simpa.annotation.AnnotationPersistenceService
import com.google.inject.Inject
import simpa.core.MosaicAssembly
import simpa.core.CoreException
import simpa.annotation.VideoTile
import simpa.core.GlobalParameters
import simpa.annotation.VideoTileTimecodeComparator

/**
 * Ingests a mosaic file and adds information (i.e. UTC date and video timecode)
 */
class InformationResolver {


    final annotationLookupService
    final annotationPersistenceService
    final dataIngestorService

    /**
     * Method pointer to a handy date format method
     */
    final df = GlobalParameters.DATE_FORMAT_UTC.&format

    @Inject
    public InformationResolver(AnnotationLookupService annotationLookupService,
            AnnotationPersistenceService annotationPersistenceService,
            DataIngestorService dataIngestorService) {
        this.annotationLookupService = annotationLookupService
        this.annotationPersistenceService = annotationPersistenceService
        this.dataIngestorService = dataIngestorService
    }

    /**
     * Convert a mosaic input file to a CSV output file
     * @param url
     * @param cameraIdentifier
     * @param sessionIdentifier
     * @param outputFile
     */
    def resolveAndWrite(URL url, cameraIdentifier, sessionIdentifier, File outputFile) {
        if (outputFile.exists()) {
            throw new CoreException("The file '${outputFile.absolutePath}' already exists")
        }
        def ingest = dataIngestorService;
        def tiles = ingest.loadTiles(url);
        def mosaicAssembly = annotationLookupService.convertToMosaicAssembly(cameraIdentifier, sessionIdentifier, tiles);
        writeMosaicAssembly(mosaicAssembly, outputFile)
    }

    def writeMosaicAssembly(MosaicAssembly mosaicAssembly, File outputFile) {
        // Write out the mosaic as a text file
        // Write a header
        outputFile.write "# Generated by ${this.class} on ${df(new Date())}\n"
        outputFile << "# Source file: UNKNOWN\n"
        outputFile << "# Camera ID: ${mosaicAssembly.cameraIdentifier}\n"
        outputFile << "# Session ID: ${mosaicAssembly.sessionIdentifier}\n"
        outputFile << "# Columns: index, date, video-date, timecode, x, y, z, width, height, pitch, roll, heading\n"

        // Write each line
        mosaicAssembly.tiles.sort({it.tileIndex}).each { tile ->
            def vt = (VideoTile) tile
            def cp = vt.cameraPosition
            def vd = vt.videoTime
            outputFile << "${vt.tileIndex},${df(vt.date)},${df(vd.date)},${vd.timecode},${cp.x},${cp.y},${cp.z},${vt.widthInMeters},${vt.heightInMeters},${cp.pitch},${cp.roll},${cp.heading}\n"
        }
    }

    /**
     * Read a mosiac input file. Associate each tile with an image and persist
     * it to the persistant storage.
     */
    def resolveAndAssociateImages(URL url, cameraIdentifier, sessionIdentifier, File imageDirectory) {

        // INgest the file
        def ingest = new DataIngestorServiceImpl02();
        def tiles = ingest.loadTiles(url);
        MosaicAssembly mosaicAssembly = annotationLookupService.convertToMosaicAssembly(cameraIdentifier, sessionIdentifier, tiles);


        // Associate each tile with an image.
        def pattern = /[1-9]+\d{0,9}/
        imageDirectory.eachFile { file ->
            if (file.absolutePath.endsWith(".png")) {
               file.name.eachMatch(pattern) { idxAsString ->

                   def idx = Integer.valueOf(idxAsString[0])
                   // Associate the image with the correct tile
                   def videoTiles = mosaicAssembly.tiles
                   for (videoTile in videoTiles) {
                       if (videoTile.tileIndex == idx) {
                           videoTile.url = file.toURI().toURL()
                           break
                       }
                   }
               }
            }
        }

        return mosaicAssembly

    }
}